# 聊天室项目文档



# 参考视频

自己从头开始做，完全没头绪，就参考了以下视频。



- [x] [Node前后端交互,包含项目实战](https://www.bilibili.com/video/BV1j5411K7EH?p=255)
- [x] [都前后端分离了，咱就别返回页面了，统统 JSON 交互](https://www.bilibili.com/video/BV1np4y1C7v5?spm_id_from=333.880.my_history.page.click)
- [ ] [【半小时带你搞定Ajax】手把手教你如何使用Ajax发送请求，实现前后端交互](https://www.bilibili.com/video/BV18y4y1L73h?p=2)
- [ ] [【JavaWeb+JAVA后台项目实战】Crm后台管理系统项目实战-Spring](https://www.bilibili.com/video/BV17o4y1R789?p=181)
- [ ] [WebSocket打造在线聊天室](https://www.bilibili.com/video/BV1r54y1D72U?p=2)
- [ ] [SpringBoot+Vue前后端分离项目](https://www.bilibili.com/video/BV1wY411J7X8?p=9)
- [ ] [尚硅谷雷神SpringBoot2零基础入门](https://www.bilibili.com/video/BV19K4y1L7MT?p=19)
- [ ] [从0开始带你手撸一套SpringBoot+Vue后台管理系统](https://www.bilibili.com/video/BV1U44y1W77D?p=5)
- [ ] [尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版](https://www.bilibili.com/video/BV1Y7411K7zz?p=160)
- [x] [前后端分离，GET、POST接口，JSON返回](https://www.bilibili.com/video/BV1NP4y1W7n4/?spm_id_from=333.788.recommend_more_video.0)
- [x] [手把手教你写java web和接口](https://www.bilibili.com/video/BV16541147s1/?spm_id_from=333.788.recommend_more_video.-1)
- [x] [Springboot极简入门教程，5分钟写一个http接口](https://www.bilibili.com/video/BV1Bq4y1j7Zz/?spm_id_from=333.788.recommend_more_video.-1) 
- [ ] [12分钟搞定基于websocket，springboot，vue的简单聊天室。](https://www.bilibili.com/read/cv16430929?spm_id_from=333.999.0.0)
- [ ] [史上最简单的spring-boot集成websocket的实现方式](https://www.bilibili.com/video/BV1Bf4y1R7fS?spm_id_from=333.337.search-card.all.click)
- [ ] [即时聊天系统(OICQ)基于springboot mybatis vue websocket](https://www.bilibili.com/video/BV1XT4y1i71M?spm_id_from=333.337.search-card.all.click)
- [ ] [SpringBoot集成WebSocket实现网页聊天（录播） ](https://www.bilibili.com/video/BV12Q4y1q7VP?spm_id_from=333.337.search-card.all.click) ⭐⭐⭐⭐⭐ 简洁有效
- [ ] [SpringBoot+Vue在线聊天系统](https://www.bilibili.com/video/BV1N94y1d7tr?p=4) 源码收费、可以看看视频
- [x] [SpringBoot+Netty+WebSocket实现在线聊天](https://www.bilibili.com/video/BV1WB4y1N7Sj/?spm_id_from=333.788.recommend_more_video.2&vd_source=07d933cd4c64b259f09ced00e89ac8a9) 主要是整合了`Netty`

#  参考账号

[乐字节](https://space.bilibili.com/1001395107)

[黑马程序员广州中心](https://space.bilibili.com/429854910)

[乐字节-嘟嘟](https://space.bilibili.com/1001395107)

[SpringBoot 整合各种框架 ](https://space.bilibili.com/325883425)

[做一条有梦想的咸鱼132]( https://www.bilibili.com/read/cv16430929?spm_id_from=333.999.0.0 )

## 参考项目

https://gitee.com/june000/lemon-im

https://gitee.com/howcode/has-chat

https://gitee.com/make-a-dream/chat-demo.git 

#  项目工程结构

经过技术选型，最后决定采用SpringBoot整合MyBatis、MySql数据库

IDEA工程也是复习了很多此前的视频，稳之又稳，创建SpringBoot工程。

[JavaWeb工程结构解析图](https://segmentfault.com/a/1190000022110134)

[Javaweb项目目录结构解析(基于IDEA)](https://blog.csdn.net/huzia/article/details/124044137)



#  项目整体 调用逻辑

虽然建立好了整个项目的结构，但是整体逻辑架构还是需要自己理一遍的，尤其是有的包/结构 其实名称叫法不一样，又或者说可以更加细化区分。

比如：一个实体类可以是`bean` /`entity`/`pojo` 等等 但其实又可以细分为`DTO` `PO` `VO` 等等、`dao`层也可以称之为`mapper`层



##  DTO/VO/PO/VO 各种对象

其实不是只有`bean` 这一单一的实体类，更加细化的话还有面向各种各样的Object

##  VO层不要和数据库的绑定

之前一直很纠结，有些返回给前端的`json` 如何与数据库字段绑定

后来发现自己犯了个错：以为所有`Bean`都直接和数据库绑定

然而就不是这样的

##  比如xxxGroup类

在前端要求的`markdown`文件中，有 `controlGroups`  `joinGroups` 两种类型

这个其实就是一个人所在的群聊，虽然名字不同，但是本质就是同一套属性 就是`Type`属性不同

差点一股脑又分成两个类。

# HelloWorld

2022.5.12的23点开始 总算是把项目建起来了

2022.5.15 周日下午过来简单配置了一下。

启动的时候，有一个小插曲：

> ***************************
> APPLICATION FAILED TO START
> ***************************
>
> Description:
>
> Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
>
> Reason: Failed to determine a suitable driver class
>
>
> Action:
>
> Consider the following:
> 	If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.
> 	If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).
>
>
> Process finished with exit code 1

这里报错了，其实意思就是 我想用数据库，但是又没有配置好，所以找不到数据库。 

索性就直接配置了数据库链接的地址，在`resources`文件夹下面的	`application.properties`里面统一配置。格式如下：

> spring.datasource.driver-class-name= com.mysql.jdbc.Driver
>
> spring.datasource.url=
>
> spring.datasource.username=root
>
> spring.datasource.password=



# 接口文档编写

今天 2022.5.16 被催着写接口文档了，之前都以为接口文档必须要用某种文件格式，其实就是一份文档。docx、markdown都行

## 接口测试

2022.5.17 

下午 跟着[5分钟写一个http接口](https://www.bilibili.com/video/BV1Bq4y1j7Zz/?spm_id_from=333.788.recommend_more_video.-1) 做了个简单的接口测试，虽然是一个简单的接口，但是做了很久因为复习了`@PostMapping`	`@RequestMapping` 这种注解

还有`Mapper` `bean` `Controller` 这种分层逻辑

```java
public interface UserMapper {
    @Select("SELECT * FROM usersinfo")
    List<User> findAll();
}
```

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class User {
    public String Username;
    public String Password;
    public String Phone;
    public String Nickname;
    public String Address;
    public String Slogan;
    public String Birthday;
    public String Job;
}
```

报错

> Description:
>
> A component required a bean of type 'com.chatroom.chatroom.mapper.UserMapper' that could not be found.

最后启动发现，压根就没有把	`UserMapper` 类交给Spring容器管理（都快忘光了） 就引入依赖

```java
<dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.3</version>
 </dependency>
```

并且在启动类 加上`@MapperScan("com.chatroom.chatroom.mapper")`

## PostMapping 使用错误

```java
@GetMapping("/testGetUser")
    public List<User> getUser(){
        return userMapper.findAll();
    }
```

这里本来想用`@PostMapping` 的，但是复习得知其实从浏览器的角度压根不能，或者说 压根就不是给普通用户准备的。

Postman 是可以访问的

## 关于UserBean的lombok注解 小插曲

看视频的时候直接给`User`类 无脑加了`@Data` 注解

![image-20220517171812619](../JavaAllNotesResources/MyNotes/images/image-20220517171812619-16527790935101.png)

结果浏览器直接给这样了

![image-20220517171909134](../JavaAllNotesResources/MyNotes/images/image-20220517171909134-16527791502535.png)

自己看首字母都小写了，一看就知道是属性名首字母小写变成 有参构造实例变量 了，赶紧去除了`@Data`注释，之后正常了。这是正常的页面显示`json` 数据

![image-20220517171834231](../JavaAllNotesResources/MyNotes/images/image-20220517171834231-16527791151683.png)



## 又扫描不到Bean 崩了 刷新maven好了

晚上吃了个饭回来，又报错找不到bean，和下午一模一样了。

```<dependency>
<dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.3</version>
 </dependency>
```

因为`@Mapper` 是在这个包里，所以`maven` 重新刷新导入了一下就好了

重点是，中间就把电脑带出实验室了一下（当天学校网不好+确实切换了网络），其他啥也没改。不知道怎么就这了。



# 跨域问题

(什么是跨域以及如何解决？通俗易懂带你彻底搞定)[https://www.bilibili.com/video/BV12U4y1f7Qi/?spm_id_from=333.788.recommend_more_video.7]

## 同源策略



## 后台解决方法：CORS

Corss Origin Resource Sharing 

1. 直接在方法上面加一个`@CrossOrigin` 

2. 添加过滤器，自己设置一个定义类

   ```java
   package com.chatroom.chatroom.configuration;
   
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.cors.CorsConfiguration;
   import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
   import org.springframework.web.filter.CorsFilter;
   //这里看清楚，CorsFliter 另一个包里面也有，别导入错误了
   
   @Configuration
   public class CorsConfig {
       /**
        * 这是专门用于解决跨域问题的Cors配置类
        * @return
        */
       @Bean
       public CorsFilter corsFilter(){
           CorsConfiguration corsConfiguration = new CorsConfiguration();
           /**
            * 本质上就是过滤器
            * 设置白名单
            * */
           corsConfiguration.addAllowedOrigin("*");//设置通配符，允许所有的域来请求
           corsConfiguration.addAllowedHeader("*");
           corsConfiguration.addAllowedMethod("*");
   
           UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();
           source.registerCorsConfiguration("/**",corsConfiguration);
   
           return new CorsFilter(source);
       }
   }
   
   ```

3. 实现`WebMvcConfigure`接口，重写`addCorsMappings`

   ```java
   @Configuration
   public class CorsConfiguration implements WebMvcConfigurer{
       @Override
       public void addCorsMappings(CorsRegistry registry) {
           registry.addMapping("/**")
                   .allowedOriginPatterns("*")
                   .allowCredentials(true)
                   .allowedMethods("GET", "POST", "DELETE", "PUT")
                   .maxAge(3600);
       }
   }
   ```

   

# 图片头像上传问题

关键问题在于：如何把头像存入数据库？

一开始我是想的：把头像文件的路径放入数据库，根据获取的地址再去对应文件路径获取图片。这样的确科学有效，节约数据库的空间。但是考虑到，项目本身是学习研究使用，所以直接使用`MediumBlob` 二进制大文件存储了，`MediumBlob`最大16M，绝对可以满足头像上传需求了。



#  集成MyBatis

## 注解开发

```mysql
@Select("SELECT * FROM usersinfo")
List<User> findAll();
```

方便快捷，但是有一定缺陷

# 配置开发

在`User.xml` 文件里面写好配置

```java
<mapper namespace="com.chatroom.chatroom.mapper.UserMapper">
    //类的全路径名字
    <update id="updateInfo">//id是函数名
       update xxxx
    </update>
</mapper>
```

#  熟悉各种注解的意思

开始编写内容发现，SpringBoot框架的注解极其弊便捷+重要

所以在此之前，应该赶紧熟悉起SpringBoot的各种开发注解



##  MyBatis Plus使用



#  数据库

Mysql的建表其实也是很耗时的，根据需求建表发现很多东西都不懂

![img](../JavaAllNotesResources/MyNotes/images/0KMESVV2BQDMNEC5HOOSESF-16530208471922.png)

比如：`json` 和`javaBean` 的互相转换 

- Gson
- FastJson
- Jackson

这些都可以转换。

保证 **字段** 和 **Bean属性**的对应，就可以封装成**对象**

所以图中的嵌套`Json` 就可以正好以面向对象方式嵌套



##  数据嵌套

有时候嵌套层数有点多，不如把本身是也有对象的都抽出来，其他的零散的属性组成一个对象。最后几个对象在后台组装。 不然的话

## 建表

而在数据库 一个`json` 就可以对应一个表，然后一个表查出来的小对象

当大对象的属性填充进去，最后大对象 转换成`json`



## 命名规范

数据库字段 不能和内置的关键词重名

`message`表里面的 `Date` `Timestamp` 很明显重名了，所以就报错

> org.springframework.jdbc.BadSqlGrammarException: 
> ### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'system,saved,distributed,seen,deleted,failure,disable_actions,disable_reactions,' at line 1
> ### The error may exist in com/chatroom/chatroom/mapper/MessageMapper.java (best guess)
> ### The error may involve defaultParameterMap
> ### The error occurred while setting parameters
> ### SQL: SELECT  _id,index_id,content,username,room_id,sender_id,avatar,date,timestamp,system,saved,distributed,seen,deleted,failure,disable_actions,disable_reactions,reactions,files,reply_message  FROM messages     WHERE (content = ?)



#  数据库字段 和 javaBean属性名

##  绑定问题

主要是带大写字母的问题，之前都没遇见

`@TableField` 注释在对应的属性上面，就表示该属性和表中某字段绑定，例如

```JAVA
@TableField("messageId")
public String messageId;
```

 表示 在数据库中有一个` messageId` 字段，必须加上这个注释 才可以测试通过

##  部分属性 表中没有

有时候javaBean 的某些属性 是表中没有的，这时候需要加一个

`@Transient` 表示该属性 对应的数据表中没有

类似的也有`@TableField(exist = false)`

## mysql 内置关键词

`date`、`timestamp`之后,还是报错 

> Error querying database.  Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'system,saved,distributed,seen,deleted,failure,disable_actions,disable_reactions,' at line 1

注意看：**near system**

其实就是此前的都没问题，那就继续往后找，那其实就是继续往后走，就可以发现`sysytem`很值得怀疑，但是mysql不高亮，一开始就没怀疑。结果改了`system`之后，`ssystem` 就好了！！！

##  学会看sql报错

> SQL: SELECT  _id,index_id,content,username,room_id,sender_id,avatar,date,timestamp,system,saved,distributed,seen,deleted,failure,disable_actions,disable_reactions,reactions,files,reply_message  FROM messages     WHERE (content = ?)  

其实就是告诉你 ，`mybatisPlus`实际上执行了哪个语句

##  SELECT + 全部字段

以前都是 `select * from`

这次偶然发现其实接全部字段也是可以的

主要区别有：

1. 查询效率上：select * 在系统解析的时候会多一步从系统表获取具体字段的步骤，因此会比select 全部字段多花时间，效率稍低。
2. 查询结果上：在表结构不修改的情况下结果相同，但是后者的顺序可以调整，前者则固定；而如果修改了表结构，前者能够获得新表结构的所有字段，后者则会在修改字段名或删除字段时报错，会在增加字段时不会输出新字段。
3. 应用场景上：select * 效率稍低但是能应对频繁调整的表结构，适应力强，可应用于开发环境，仅极少数特殊业务场景会在生产环境使用场景；后者效率稍高语意明确，更能清晰的表达业务的需求，强烈建议在生产环境中使用。

##  #{} ${}的区别

https://blog.csdn.net/weixin_41231928/article/details/105120292

> **#{}** **是** **占位符** **：动态解析 -> 预编译 -> 执行**
>
> **${}** **是** **拼接符** **：动态解析 -> 编译 -> 执行**

sql的预编译也是一样的道理，在执行前就编译好，等执行时直接取编译结果去执行。省去编译时间。sql预编译后会在参数位置用占位符表示。 预编译可以类比java类的编译，java类被编译成class文件，载入虚拟机，载入虚拟机的字节码文件可以先被编译成机器吗，那么在执行某行代码的时候就可以直接执行编译后的机器码，而不用从字节码开始编译再执行，那么执行效率就高了。这也是为啥热机状态比冷机状态可以抗更多负载的原因。

预编译可以将多个操作步骤合并成一个步骤，一般而言，越复杂的sql，编译程度也会复杂，难度大，耗时，费性能，而预编译可以合并这些操作，预编译之后DBMS可以省去编译直接运行sql。
预编译语句可以重复利用。
把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。

> 1. **#{} 对应的变量会自动加上单引号** 
> 2. **${} 对应的变量不会加上单引号** 

> 1. **#{} 能防止sql 注入**
> 2. **${} 不能防止sql 注入**

#  测试

建立好了表之后可以测试一下，一堆bug爆出来之后终于通了。

> [Messages{_id=1643, indexId=323, content='这是一条消息测试', username='xupt', senderId='333', avatar=123, date=Fri May 20 00:00:00 GMT+08:00 2022, timestamp=Fri May 20 12:06:23 GMT+08:00 2022, system=false, saved=true, distributed=true, seen=true, deleted=true, failure=true, disableActions=true, disableReactions=true, reactions=123, files=123, replyMessage=123}]

拿出来了一个`Message`类型的数据





#  登陆注册接口

2022.05.19 终于开始了

## 后台接口获取参数

一开始就想着直接接受`json`对象，上来就用

```java
@PostMapping("/testGet")
    public User getUser(@RequesBody User user){
        System.out.println(user);
        return user;
    }
```

`@RequestBody` 就是想把拿过来的对象，封装成`User`类

但是其实不用那么复杂，她那边就是单纯给了个参数而已。所以就是接受所给的参数即可。自己自行构造一个`bean` 

```java
@PostMapping("/testGet")
    public String getUser(@RequestParam("Phone") String Phone){
        System.out.println(Phone);
        return Phone;
}
```

当然除了`@RequestParam`之外，还有些其他的方式比如 

```java
    @GetMapping("/hello/{name}")
    public String hello(@PathVariable("name") String name){}
```





# 关于返回json格式的一系列问题

##  返回格式

那边要求返回

```json
{
    code:    ;
    user:
    {
       username:    ;
       password:    ;
    
     }
}
}
```



这种嵌套的`Json` ，其实这非常符合`java` 面向对象的思想

比如图里的，直接搞一个新的类，封装`code` 和 `User`  属性进去即可

然后这里就牵扯到转换了

## Gson、Jackson、FastJson

这几个都是方便的转换工具包，直接 类和`json` 互相转换



## 直接用@ResponseBody返回

或者不需要用转换包，直接利用注释的

```java
public LoginStaus login(User user) {
          QueryWrapper<User> queryWrapper = new QueryWrapper<>();
          queryWrapper.eq("Phone",user.Phone);
          queryWrapper.eq("Password",user.Password);
          //自己定义了一个构造器

          User validUser = usermapper.selectOne(queryWrapper);
          System.out.println(validUser);
          LoginStaus loginStaus = new LoginStaus();
          if (validUser != null) {
               loginStaus.setCode(1);//登陆成功，有此人
               loginStaus.setUserTry2Login(validUser);//合法的用户塞进去
          } else{
               //查无此人
               loginStaus.code=0;//登陆失败，查无此人
          }
          /**这里利用gson转换成json 格式 开始返回*/
          return loginStaus;
   }
```

这里其实就是返回了一个`LoginStaus`的对象，然后在`Controller`层那边加上`@ResponseBody` 

![image-20220524161053975](../JavaAllNotesResources/MyNotes/images/image-20220524161053975-16533798550791.png)

查询成功、返回来的结果

##  关于注入IOC管理

上手项目才深刻体会到`SpringBoot`的各处细节

自己打包的一个类，其实只是用来方便转换成`json`	，但是发现 

如果要`@Autowired` 那就是针对 成员变量、某个实例的

`@Component`才是对于类的





#  短信

2022/05/25 下午

经过一波大费周章的，总算是成功在阿里云的 云商城 买到了不需要工商执照的短信发送服务。



#  登陆+注册 拦截器验证

搭好了框架之后，就很快的把登陆注册一系列都写好了

2022/5/25 晚 开始考虑过滤器、拦截器的问题

一个是前端那边，注册先填写了正确验证码后、设置密码，那就得短暂的存储一下这个手机号

目前考虑 `Redis` 10分钟存住

登录肯定是要拦截器、过滤器的

##  Token\Cookie\Session

当一次登录后，下次登陆无需再次输入账号密码，该如何做到也可以直接登录？

> 比如B站，打开就可以直接用而不用登录

这里就可以用`Token`。

> Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

> Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

> 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

[什么是token](https://www.jianshu.com/p/24825a2683e6)

[Token+Redis登录认证](https://www.bilibili.com/video/BV1k34y1b7SC?spm_id_from=333.337.search-card.all.click)

[朝月余晖](https://space.bilibili.com/27385378)

 [是金山老师](https://space.bilibili.com/548657327)

##  学习Redis整合SpringBoot

因为要用到`token` 操作`redis ` 数据库，所以复习用`RedisTemplate`操作

2022/05/26 晚 复习redis

`RedisTemplate` 其实就是引入一个maven包 然后用`redisTemplate` 对象操作即可

记得打开`redis-server`服务器端！

##  Redis+Token 和 JWT

成功使用了`Token` + `Redis` 的技术进行存储。



#  关于MySQL的一点小问题

首先复习了关于`MySQL`	的语句中，如何传递参数进去

就是要用到占位符

```mysql
insert into usersinfo (Username,Password) values (#{phone},#{password});
```



其次就是遇到了问题，因为建表的时候把Username设置了`NOT NULL`且没有指定默认值。

又不准空着、又不准默认值，当然报错啦。

其实这就是建表的时候没有和前端沟通好，以为用户名`Username` 才是最主要、唯一的，其实应该是手机号

就应该先把	`Username` 的主键约束去除，否则无法修改为允许`NULL`，然后改成`phone` 为主键

## 解决办法

就是修改`Username`字段的权限为 可以为空。

```mysql
ALTER TABLE usersinfo DROP PRIMARY KEY;//删除之前的错误主键Username
ALTER TABLE usersinfo MODIFY Username VARCHAR(32) NULL;//取消Username的NOT NULL
ALTER TABLE usersinfo ADD PRIMARY KEY (Phone);//把Phone改成主键
```



-----------------------------------------

#  MileStone！登陆注册完美实现

2022/5/30 23:00 完美实现注册+登录



# 聊天室建表

(如果有的字段和mysql内置的重名了，那就可以用 `  符号引用起来防止被识别为内置的高亮 )

之前一直以为的`Java Bean` 属性必须对应相应的数据库字段，后面发现也可以不完全一一对应，其实不必，没有的字段自己暂时先`null`



```java
@Test
void testLackArgs() {
     List<Room> roomsLackTest = roomMapper.FindAllRooms();
     Iterator<Room> it = roomsLackTest.iterator();
      while(it.hasNext()){
         System.out.println(it.next().toString());
      }
}
```



![image-20220531172154298](../JavaAllNotesResources/MyNotes/images/image-20220531172154298-16539889166191.png)



![image-20220531172238372](../JavaAllNotesResources/MyNotes/images/image-20220531172238372-16539889593805.png)

比如

```java
 class User{
     int age;
     Sting name;
 }
 class Message{
     String content;
     Timestamp time;
     User sender;
 }
```

 很明显在`MYSQL` 数据库那边不可能搞一个`User` 字段来存`Sender`，所以查的时候 可以不从数据库中查`Sender` ，先把基础数据查出来、再去`User`表查那个正确的`Sender` 最后填充到	`Message.sender` 属性，以构造一个完整的`Message` 、变成`json` 返回去

 

##  建表+建立对应Bean类

自从想清楚 `Java Bean` 的数据，和数据库字段不一定完全对应后，就思路开阔了。

遇到嵌套`json`即不是`mysql`支持的基本类型 就单独拿出来做一个类，到时候填充。

![image-20220531181225342](../JavaAllNotesResources/MyNotes/images/image-20220531181225342-16539919463177.png)

![image-20220531181245206](../JavaAllNotesResources/MyNotes/images/image-20220531181245206-16539919660989.png)

具体的属性就按照前端给过来的`json` 内容一个个做就好



# WebSocket

之前的`Java SpringBoot` 、`JavaWeb` 其实都没接触过`WebSocket`这一次边学边用，并且第一次阅读英文文档，感觉很透彻！记录一下！2022/5/31 21:00

> https://www.byteslounge.com/tutorials/java-ee-html5-websocket-example
>
> 一个简单的WebSocket 小例子讲解，快速上手 
>
> https://www.oschina.net/translate/java-ee-html5-websocket-example
>
> 对应的中文翻译



2022/5/31 22：10 `@OnOpen`半天找不到  记得首字母大写

##  SpringBoot演示 （外网高质量贴）

[Building a chat application with Spring Boot and WebSocket](https://www.callicoder.com/spring-boot-websocket-chat-example/)

外网高质量贴，不得不说 国内`SpringBoot+WebSocket`的聊天室项目真的资源匮乏，全都是`Node.js` 做后台的。

[手把手搭建WebSocket多人在线聊天室（SpringBoot+WebSocket）](https://blog.51cto.com/rude3knife/2911879)

这个是国内的翻译帖子，内部还有进阶分布式版本



##  @OnOpen

```java
@OnOpen
public void onOpen(Session session){}
```

这里的	`Session`  其实就是 一个浏览器界面的会话

比如说我用`Firefox` 登录上线了，其实就是一个`Session`了，这个`Session`  在服务器这边其实就是一个用户，只不过需要我们手动维护一个	`ConcurrentHashMap<String,Session>` 来找到这个用户的用户名

```java
@OnOpen
    public void onOpen(Session session, EndpointConfig endConfig){
        //一旦建立链接 就可以先赋值了
        this.Isession=session;
        //从GetHttpSessionConfigurator配置类的modify方法 获取HttpSession对象
        HttpSession httpSession =(HttpSession) endConfig.getUserProperties().get(HttpSession.class.getName());
        this.IhttpSession = httpSession;

        //接下来就是从httpSession中拿到用户名,，因为之前登录的时候，登录用户放进来了
        String username = (String) IhttpSession.getAttribute("username");

        //放入在线列表
        onlineUsers.put("username",this);
    }
```

其实这里不用如此麻烦，简单 的方法就是直接在参数表里写上一个 `(@Param String username)`
`@ServerEndpoint(value="chatPrivate/{username}“)` 就可以很轻松的把当前登录用户拿出来了
而不用那么麻烦的放在Session 再取

 

## @OnMesage



##  关于Jakcson\JSONObject

视频教程里出现的基本都是使用了`Jackson`包操作`Json` `Java Bean` 之间的相互转化

值得一提的是，似乎`SendMessage` 里面是把`String` 发送出去、前端那边可以自动识别`String`类型的并且解读为`Json` 



```java
//其中message是传输过来的String类型的消息，但是可以被识别、拆解为Json
JSONObject inMesObj = JSONUtil.parseObj(message);
        String toUsername = inMesObj.getStr("to"); // to表示发送给哪个用户，比如 admin
        String text = inMesObj.getStr("text"); // 发送的消息文本  hello

```

由代码可看出来，根据转换好的`mesObj` 可以拿需要的内容，并且再填充到自己的`Message Bean` 里面存储都可以

`Session toSession = sessionMap.get(toUsername);`

  根据 to用户名 来获取接收者的 `Session`，再通过`session`发送消息出去

```java
JSONObject outMesObj  = new JSONObject();
            outMesObj.set("from", username);  // from 是 zhang
            outMesObj.set("text", text);  // text 同上面的text
            this.sendMessage(jsonObject.toString(), toSession);
```

对称的操作，知道要发给谁之后，封装好、再发出去



```java
/**
 * 服务端发送消息给客户端
 */
private void sendMessage(String message, Session toSession) {
       try {
         log.info("服务端给客户端[{}]发送消息{}", toSession.getId(), message);
         toSession.getBasicRemote().sendText(message);
      }catch (Exception e) {
         log.error("服务端发送消息给客户端失败", e);
      }
}

```

想发给哪个`Session`，就调用该`Session`的`getBasicRemote().sendText(message)`方法 



#  群聊思路⭐

##  1.0 基于普通遍历思路

一直受困于群聊该怎么做，毕竟私聊还是很简单的，毕竟只需要发给固定的人。

在网上搜了一圈*WebSocket群聊如何实现* 几乎都是清一色的一次性所有人都收到消息，然而我们想要的肯定不是这个效果。换言之，这是全聊。群聊可以理解为 部分人的全聊 或者是 多个人的私聊。

根据刚才的理解：`Session` 其实就代表着一个用户，那么其实就是遍历一个集合、给这个集合里面的`Sessions`发消息。

这个集合`Set` 就是之前的`Rooms` ,这个群有哪些人,就给哪些（`Sessions`）发不就行了吗？！

Rooms之前存储了`Phone`，那就很好办了

1. 从`Room`数据库取出该群聊的所有`Phone` 
2. 然后建立`ConcurrentHashMap<Phone,Session>` 即可
3. 遍历该`HashMap`的`Values` ,把一个个`Session `找出来、发消息！



##  2.0 基于聊天室思路

2022.06.05 晚21:30 前端设计的思路是：

基于聊天室	`Room`  的思路，把私聊当成两个人的群聊。当一个消息过来的时候，需要知道是谁发的、在哪个聊天群/房间`Room` 发的，然后去找，这个群里有哪些人，这样再去数据库里面查。

`message.getRoomID`  拿到聊天室

`room` 去数据库里面查`List<Users>` 

根据遍历`List<Uers>` ，拿到一个个群成员，然后去`HashMap<String ,Session>` 

##  List<T> 的赋值问题

查出来的是一个`List<File>` 但是`msg`作为`javaBean`本身也有一个List<File> 的属性，赋值的话

一开始是 `A=B` 这样 但是也不放心，正规做法是

`ArrayList B　＝ new ArrayList<> (A);`

`ArrayList B　＝ A.clone();`

`ArrayList B　＝ new ArrayList<String>(); B.addAll(A);`

`for(String s: A) B.add(s);`

##  深浅拷贝

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存， 所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。。

浅拷贝对应的就是深拷贝，深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

#  带图片/文件

其实这个就涉及到了`MultipartFile` 类的处理，本质也不难，CSDN很多可以直接搜到。本质上就是接口里，接收一个

```JAVA
@RequestMapping("jsonDataAndUploadFile")
@ResponseBody
public String jsonDataAndUploadFile(@RequestPart("uploadFile") MultiPartFile uploadFile, @RequestPart("jsonData") Person person) {
    StringBuilder sb = new StringBuilder();
    sb.append(uploadFile.getOriginalFilename()).append(";;;"));
    return person.toString() + ":::" + sb.toString();
}

————————————————
版权声明：本文为CSDN博主「借物小人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u012894692/article/details/115875674
```

而对于 `@RequestPart`和`@RequstParam`

> 译文：
> 1.@RequestPart这个注解用在multipart/form-data表单提交请求的方法上。
> 2.支持的请求方法的方式MultipartFile，属于Spring的MultipartResolver类。这个请求是通过http协议传输的。
> 3.@RequestParam也同样支持multipart/form-data请求。
> 4.他们最大的不同是，当请求方法的请求参数类型不再是String类型的时候。
> 5.@RequestParam适用于name-valueString类型的请求域，@RequestPart适用于复杂的请求域（像JSON，XML）。
> ————————————————
> 版权声明：本文为CSDN博主「向小凯同学学习」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/wd2014610/article/details/79727061



##  上传个人头像

这个是最简单的，单独一个接口，就简单的接收即可

##  群头像

群头像就是`form` 类型的接收，很多CSDN都可以由

##  消息内的图片

前端支持`Blob` ，那就非常好了，后台的数据库`mysql`也支持`Blob`类型，可以直接操作使用的

[如何在 MySQL / MariaDB 中实现图片存储，BLOB 数据类型详解](https://kalacloud.com/blog/how-to-use-the-mysql-blob-data-type-to-store-images-with-php-or-kalacloud/)

之前设计的表中，其实还是沿用了记录地址的思路，可以考虑加一个`Blob`字段，直接存图片



报错：其实这个 没啥大问题，就是传过来的`Json`，没有准备好对应的`Bean`实体类字段而已

> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: 
>
> Unrecognized field "roomId" (class com.chatroom.chatroom.beanPo.Messages), not marked as ignorable
>
>  (19 known properties: "disableReactions", "distributed", "saved", "failure", "indexId", "date", "system", "senderId", "disableActions", "username", "files", "content", "_id", "seen", "replyMessage", "reactions", "timestamp", "avatar", "deleted"])at 
>
> [Source: (String)"
>
> {"roomId":2,
>
> "content":"单方事故瑞典歌手🤑😚",
>
> "senderId":1234,
>
> "username":"PintTing",
>
> "avatar":" ",
>
> "date":"2022-06-07"，
>
> "timestamp":"21:10:44",
>
> "system":false,
>
> "saved":true,
>
> "distributed":true,
>
> "seen":true,
>
> "deleted":false,
>
> "failure":false,
>
> "disableActions":false,
>
> "disableReactions":false,
>
> "files":[
>
> ​     {"name":"Lunix进程管理",
>
> ​		"size":91233,"
>
> ​		type":"image/jpeg",
>
> ​		"audio":false,
>
> ​		"duration":0,
>
> ​		"url":"blob:http://localhost:8080/99582bc7-63c9-4e70-845d-8730a797eed5",
>
> ​		"preview":"blob:http://localhost:8080/99582bc7-63c9-4e70-845d-8730a797"
>
> ​	}
>
> }
>
> ​		[truncated 296 chars]; line: 1, column: 12]
>
>  (through reference chain: com.chatroom.chatroom.beanPo.Messages["roomId"])

**19 known properties** 注意这里，其实意思就是识别出19个字段了



2022/06/08 晚21：00  随便创建了一个`Blob`的表，并且创建了对应的`Bean`、`Mapper` 遇到几次波折

最主要的就是 错以为`Java`内置的`Blob`类型~~可以~~用于接收查询出来的`Blob`类型	

然而Blob是对应**Byte[]** 字节数组的！

其次就是一些细节问题，**一条数据**对应的是一个`JavaBean` 不要混了

#  数据库 2.0

用户User、群聊房间`Room`  、消息`Message` 

用户之间谁和谁是好友、哪个消息是哪个用户发的、这个消息属于哪个房间、这个房间里有哪些用户

对于数据库知识的一次集中应用

##  整体用户关系设计图

##  用户和群聊（经典多对多）

一个用户有可以存在于多个群聊中，一个群聊中也存在多个成员。

典型的 多对多 关系，之前学习数据库的时候 学艺不精，没有

就是`Users`表 和 `Rooms` 表 之间的多对多关系

![image-20220607192429559](../JavaAllNotesResources/MyNotes/images/image-20220607192429559-16546010704651.png)

[多表操作—多对多关系数据操作](https://www.bilibili.com/video/BV1gU4y157JN?spm_id_from=333.999.0.0)

```mysql
ALTER TABLE UserRoom ADD FOREIGN KEY(Phone) REFERENCES usersinfo (Phone);
ALTER TABLE UserRoom ADD FOREIGN KEY(roomId) REFERENCES room (roomId);
```

设置中间表的两个字段 各自和用户信息表、群聊房间表 建立外键

`usersinfo` 的`Phone` 对应 `userroom`  的`Phone`  `room` 的`roomId` 对应 `userroom`  的`roomId`

 ![image-20220607213107647](../JavaAllNotesResources/MyNotes/images/image-20220607213107647-16546086738921.png)

所以`userroom`表就是这样的效果 ![image-20220607213154507](../JavaAllNotesResources/MyNotes/images/image-20220607213154507-16546087163913.png)

ps: 外键就约束、保证数据合法、合理性的。

消息表`Message`的`roomId`是跟随群聊表`room` ，所以不存在的群聊ID，在消息表都不允许存入

比如room表不存在5号room,`Message`表里就无法有一条`roomId`为5的数据，否则就报错

> Cannot add or update a child row: a foreign key constraint fails 	



> ##  用户之间的好友关系
>
> 可以直接用`Redis`存，因为其实就是两个人之间的关系，`Redis`本身提供`List`，利用`RedisTemplate.opsForList()` 可以直接存储、删除
>
> 一个`List`的`key`就是登录用户的手机号，然后内容就是好友，不用`Set`是因为好友的刷新顺序也有要求。
>
> 需要提取一个人的所有好友，就直接
>
> ```   java
> List<String> friends = redisTemplate.opsForList.range(userPhone,0,-1);
> ```
>
> 返回所有好友，删除好友等都有。
>
> PS：如果是备注，那就完全不同了，真的需要用到`mysql`了，mybatis-Plus创建表还是挺复杂了，就以后再说了
>



#  Java 操作 Blob 

```JAVA
@Test
void showBlob() throws IOException {
        List<BlobTest> blobTests = blobMapper.showBlobs();
        Iterator<BlobTest> it = blobTests.iterator();
        System.out.println(blobTests.size());
        BlobTest next = it.next();
        String picName = next.toString().substring(3, 6)+".jpg";
        File tempFile = new File("D:\\个人文件\\软协相关\\" + picName);
        OutputStream os = new FileOutputStream(tempFile);
        os.write(next.pictures);
}
```

`Blob` 类型在`Java`里面其实就用`Byte[]`字节数组接收即可，之前自作主张用了`Blob`内置类型，反而报错。

然后用`File`文件类操作即可



#  Form-data 报错

2022-06-10 13:15:03.237  INFO 17500 --- [nio-8080-exec-9] org.apache.tomcat.util.http.Parameters   : Character decoding failed. Parameter [------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name] with value ["userId"

1234
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="roomId"

2
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="messageId"

2022-6-1013:153306
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="name"

Lunixè¿ç¨ç®¡ç
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="size"

91233
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="type"

image/jpeg
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="index"

0
------WebKitFormBoundaryr5zqGgof4qHSnMrc
Content-Disposition: form-data; name="img"; filename="Lunixè¿ç¨ç®¡ç"
Content-Type: image/jpeg

ÿØÿà JFIF  Ü Ü  ÿÛ C	
2!!22222222222222222222222222222222222222222222222222ÿÀ ·ò" ÿÄ           	
ÿÄ µ   } !1AQa"q2#B±ÁRÑð$3br	
%] **has been ignored. Note that the name and value quoted here may be corrupted due to the failed decoding. Use debug level logging to see the original, non-corrupted values.**
 **Note: further occurrences of Parameter errors will be logged at DEBUG level.**
2022-06-10 13:15:03.250 ERROR 17500 --- [nio-8080-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is

 **java.lang.ClassCastException: org.apache.catalina.connector.RequestFacade cannot be cast to org.springframework.web.multipart.MultipartHttpServletRequest] with root cause**

**java.lang.ClassCastException: org.apache.catalina.connector.RequestFacade cannot be cast to org.springframework.web.multipart.MultipartHttpServletRequest**
	at com.chatroom.chatroom.controller.MessageController.getFile(MessageController.java:49) ~[classes/:na]
	



##  解决方法：RequestFacade cannot be cast to MultipartHttpServletRequest异常

https://blog.csdn.net/sinat_32469267/article/details/99777575?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-99777575-blog-49576281.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-99777575-blog-49576281.pc_relevant_paycolumn_v3&utm_relevant_index=3

内部的解决方法一和三都试了



##  自己找到的



1. 通过检查上传数据的Content-Type是multipart/form-data；跟网上查的一致；并无异样。
2. 在网上找到说是axios的配置问题，导致上传的数据被序列化导致为null的；引致后台报错为空指针错误。通过对axios配置文件的检查也发现axios对Formdata的数据有进行判断，并无对FormData数据进行序列化。
3. 那问题来了。既然数据没有被序列化，也到达了后台，但后台却获取为null，原因在于我上传FormData数据的定义名字跟后台获取的名字不一致所导致的问题。主要一开始没跟后台沟通好导致的错误。
4. ![image-20220610154311293](../JavaAllNotesResources/MyNotes/images/image-20220610154311293-16548469922821.png)

居然是`application/json`的header？

![image-20220610155248590](../JavaAllNotesResources/MyNotes/images/image-20220610155248590.png)



----------------------------

# 期末考（6.28~7.9） 

半个月左右的时间几乎停滞 时间拿去复习了



#  完善文件功能

2022\07\12

有了传基于BASE64传 图片 的经验，音频、视频也不在话下了，回来就先把这个功能给做了

#  内网穿透

2022\07\13

暑期回到家，那就顺便做了个内网穿透。因为前后端各自回家，肯定不能再直接在一个局域网下面了

顺便学习了**内网穿透**的知识

##  基本概念

> 内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。下面就相互通信的主机在网络中与 NAT 设备的相对位置介绍内网穿透方法。 [1] 
>
> UDP 内网穿透的实质是利用[路由器](https://baike.baidu.com/item/路由器/108294)上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽。

> 内网穿透能够使仅可被内网访问的服务被公网上的设备访问到。
>
> 举个例子，当我需要使用学校实验室的服务器，只能通过使我的电脑连接到学校的网络（与服务器处于同一局域网），再通过局域网下的 IP  地址（内网地址）访问服务器；而当我的电脑和服务器不处于同一局域网时，我便无法连接到服务器。通过内网穿透的方式，我便可以通过一些中介将我的请求转发给服务器，达到和服务器近似处于同一局域网的效果。
>
> 再举个例子，在我的家中有一台主机一直开机，硬盘上存放着一些影视资源。由于默认情况下，我们使用的是 ISP 分配的随机 IP  地址，家中主机的 IP  地址不固定，在外我也就无法和家中的主机建立稳定联系，获取这些影视资源。而通过内网穿透，我便可以通过一些中介进入家庭内网，访问硬盘资源，甚至可以建立 P2P 连接。

因为自己写的SpringBoot+Vue 项目 肯定不能只在自己的电脑上跑起来，需要真的允许外部网络也可以访问到。比如我的电脑主机在A地、前端交互在B地，那么肯定不能依靠局域网WIFI来通讯。

所以内网穿透就是实现允许外部访问本地。

##  实现技术

最大佬的就ngrok

- Frp 这个是最强大的、高度可自定义的
- 钉钉内网穿透 最简单的，快速便捷 但是有内存泄漏风险+限制诸多、容易被封
- natapp...

##  效果展示

> Tunnel Status                 online                                                                                    Version                       1.7/1.7                                                                                   Forwarding                    http://xuptchatroom.vaiwan.com -> 127.0.0.1:8080                                          Forwarding                    https://xuptchatroom.vaiwan.com -> 127.0.0.1:8080                                         Web Interface                 127.0.0.1:4040

就是   http://xuptchatroom.vaiwan.com  成功 映射到了 127.0.0.1:8080 端口



# 数据库 

2022\07\13

##  级联操作

之前设置用户和群聊关系的时候，设置了多对多的外键。

如今想解散群聊，即 `Delete` 操作 直接操作肯定不行，这边主表没了，那边副表咋办？

所以需要`级联操作` 主表删除的`id=1`的数据，那么副表的对应数据也自动没了

例如：

这个群聊没了，那么对应的群聊关系也都没了



CREATE TABLE `userroom` (
  `Phone` varchar(15) DEFAULT NULL,
  `roomId` tinyint NOT NULL,
  KEY `Phone` (`Phone`),
  KEY `roomId` (`roomId`),
  CONSTRAINT `userroom_ibfk_1` FOREIGN KEY (`Phone`) REFERENCES `usersinfo` (`Phone`),
  CONSTRAINT `userroom_ibfk_2` FOREIGN KEY (`roomId`) REFERENCES `room` (`roomId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3

##  开/关外键

```mysql
SET FOREIGN_KEY_CHECKS = 0;
DELETE FROM room WHERE roomId=1;
SET FOREIGN_KEY_CHECKS = 1;
```

收外键影响，必须先关闭外键然后再删除整个群聊。

##  多条sql语句

与此同时带来的问题就是：以上是多条语句，就必须要在配置里写上`允许mybatis一次性操作多条语句`

```
spring.datasource.url=...&allowMultiQueries=true
```



##  IN 子查询

想要先从	`userroom` 表中查出一个用户有哪些群聊、然后再拿去`room` 表中查完整的room内容

嵌套查询是正确的，但是不能用 `=` 简单连接，因为查出来肯定有多个`roomId` ，等于号只能用于查一个。

必须要用`in` 

> IN 运算符用于 WHERE 表达式中，以列表项的形式支持多个选择，语法如下 
>
> WHERE column IN (value1,value2,...)
> WHERE column NOT IN (value1,value2,...)



##  EXIST ALL

类似的还有exist、all 查询

##  字段名下划线问题

之前`_id`当成字段名 结果从mysql里面总是查不出来、都是0，还以为是查询方式的问题。`mybatis-plus` 也不行，后来改了字段名为`id`就好了



#  关于加好友/加群 同意后才能执行

一次申请，那么接收方就要一次同意/反对

同意/拒绝的消息其实又要返回去，消息不止一次来回。

到底消息通知是和`message` 一致	还是怎样 需要统一

#  基本功能收尾

2022.07.15

一个 简易的聊天室软件的功能基本做完了，私聊群聊、增删改查、好友、群等

当然还有一点小部分没完善，比如加好友的申请



剩下的点

1. 加好友\加群 功能还没完善

2. 我应该开放我服务器主机的某个文件夹，以供客户端获取图片、视频、声音文件

3. 以及前端需求里面的  

   > 4.2.2 搜索用户或者群聊

   我没看懂...所以需要咨询前端才能做

4.  

5. 



#  

#  后续 +Netty+Nginx

一个项目大部分都是SpringBoot + Mybatis +WebSocket也就前期缓存有一点用	`Redis`  

感觉技术栈用的还是太少了，后续想复制一份该项目，改造一下，把	`Netty`加进去，甚至于`Nginx` 都希望可以用上
